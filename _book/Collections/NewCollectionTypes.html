<!DOCTYPE HTML>
<html lang="en-US" manifest="../manifest.appcache">
    <head prefix="og: http://ogp.me/ns# book: http://ogp.me/ns/book#">
        
        <meta charset="UTF-8">
        <title>New Collection Types | Guava学习笔记</title>

        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="robots" content="index, follow">
        <meta name="author" content="xionglie">
        <meta name="description" content="[Guava学习笔记](http://xionglie.github.io/note-learning-guava)">
        <meta name="keywords" content="gitbook,github" >
        <meta name="generator" content="www.gitbook.io">

        
        <link rel="next" href="../Collections/UtilityClasses.html" />
        
        
        <link rel="prev" href="../Collections/ImmutableCollections.html" />
        

        <meta property="og:title" content="New Collection Types | Guava学习笔记">
        <meta property="og:site_name" content="Guava学习笔记">
        <meta property="og:type" content="book">
        <meta property="og:locale" content="en_US">

        <meta property="book:author" content="https://github.com/xionglie">
        <meta property="book:tag" content="GitBook">

        <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">
        <meta name="apple-mobile-web-app-capable" content="yes">
        <meta name="apple-mobile-web-app-status-bar-style" content="black">

        <link rel="shortcut icon" href="../gitbook/images/favicon.ico" type="image/x-icon">
        
    </head>
    <body>
        

        <link rel="stylesheet" href="../gitbook/style.css">
        


        
    <div class="book" data-github="xionglie/note-learning-guava" data-level="2.2" data-basepath=".." data-revision="1399425441056">
    <div class="book-header">
    <!-- Actions Left -->
    
    <a href="https://github.com/xionglie/note-learning-guava" target="_blank" class="btn pull-left"><i class="fa fa-github-alt"></i></a>
    
    <a href="#" class="btn pull-left toggle-summary"><i class="fa fa-align-justify"></i></a>
    <a href="#" class="btn pull-left toggle-search"><i class="fa fa-search"></i></a>
    <span id="font-settings-wrapper">
        <a href="#" class="btn pull-left toggle-font-settings"><i class="fa fa-font"></i>
        </a>
        <div class="dropdown-menu font-settings">
	<div class="dropdown-caret">
  <span class="caret-outer"></span>
  <span class="caret-inner"></span>
</div>

	<div class="btn-group btn-block">
		<button id="reduce-font-size" class="btn btn-default">A</button>
		<button id="enlarge-font-size" class="btn btn-default">A</button>
	</div>

	<ul class="list-group font-family-list">
		<li class="list-group-item" data-font="0">Serif</li>
		<li class="list-group-item" data-font="1">Sans</li>
	</ul>

	<div class="btn-group btn-group-xs btn-block color-theme-list">
	  <button type="button" class="btn btn-default" id="color-theme-preview-0" data-theme="0">White</button>
	  <button type="button" class="btn btn-default" id="color-theme-preview-1" data-theme="1">Sepia</button>
	  <button type="button" class="btn btn-default" id="color-theme-preview-2" data-theme="2">Night</button>
	</div>
</div>

    </span>

    <!-- Actions Right -->
    <a href="#" target="_blank" class="btn pull-right" data-sharing="google-plus"><i class="fa fa-google-plus"></i></a>
    <a href="#" target="_blank" class="btn pull-right" data-sharing="facebook"><i class="fa fa-facebook"></i></a>
    <a href="#" target="_blank" class="btn pull-right" data-sharing="twitter"><i class="fa fa-twitter"></i></a>

    
    <a href="https://github.com/xionglie/note-learning-guava/stargazers" target="_blank" class="btn pull-right count-star"><i class="fa fa-star-o"></i> Star (<span>-</span>)</a>
    <a href="https://github.com/xionglie/note-learning-guava/watchers" target="_blank" class="btn pull-right count-watch"><i class="fa fa-eye"></i> Watch (<span>-</span>)</a>
    

    <!-- Title -->
    <h1>
        <i class="fa fa-spinner fa-spin"></i>
        <a href="../" >Guava学习笔记</a>
    </h1>
</div>

    <div class="book-summary">
    <div class="book-search">
        <input type="text" placeholder="Search" class="form-control" />
    </div>
    <ul class="summary">
        
        <li>
            <a href="https://github.com/xionglie" target="blank">About the author</a>
        </li>
        <li>
            <a href="https://github.com/xionglie/note-learning-guava/issues" target="blank">Questions and Issues</a>
        </li>
        <li>
            <a href="https://github.com/xionglie/note-learning-guava/edit/master/Collections/NewCollectionTypes.md" target="blank">Edit and Contribute</a>
        </li>
        <li class="divider"></li>
        
        <li data-level="0" data-path="index.html">
            <a href="../"><i class="fa fa-check"></i> Introduction</a>
        </li>
        
            <li  data-level="1" data-path="BasicUtilities/README.html">
                
                <a href="../BasicUtilities/README.html">
                    <i class="fa fa-check"></i> <b>1.</b> 基本工具 Basic Utilities
                </a>
                
                
                <ul class="articles">
                    
                        <li  data-level="1.1" data-path="BasicUtilities/UsingAndAvoidingNull.html">
                            
                            <a href="../BasicUtilities/UsingAndAvoidingNull.html">
                                <i class="fa fa-check"></i> <b>1.1.</b> Using and avoiding null
                            </a>
                            
                        </li>
                    
                        <li  data-level="1.2" data-path="BasicUtilities/Preconditions.html">
                            
                            <a href="../BasicUtilities/Preconditions.html">
                                <i class="fa fa-check"></i> <b>1.2.</b> Preconditions
                            </a>
                            
                        </li>
                    
                        <li  data-level="1.3" data-path="BasicUtilities/Ordering.html">
                            
                            <a href="../BasicUtilities/Ordering.html">
                                <i class="fa fa-check"></i> <b>1.3.</b> Ordering
                            </a>
                            
                        </li>
                    
                        <li  data-level="1.4" data-path="BasicUtilities/ObjectCommonUtilities.html">
                            
                            <a href="../BasicUtilities/ObjectCommonUtilities.html">
                                <i class="fa fa-check"></i> <b>1.4.</b> Object common methods
                            </a>
                            
                        </li>
                    
                        <li  data-level="1.5" data-path="BasicUtilities/Throwables.html">
                            
                            <a href="../BasicUtilities/Throwables.html">
                                <i class="fa fa-check"></i> <b>1.5.</b> Throwables
                            </a>
                            
                        </li>
                    
                </ul>
                
            </li>
        
            <li  data-level="2" data-path="Collections/README.html">
                
                <a href="../Collections/README.html">
                    <i class="fa fa-check"></i> <b>2.</b> 集合 Collections
                </a>
                
                
                <ul class="articles">
                    
                        <li  data-level="2.1" data-path="Collections/ImmutableCollections.html">
                            
                            <a href="../Collections/ImmutableCollections.html">
                                <i class="fa fa-check"></i> <b>2.1.</b> Immutable collections
                            </a>
                            
                        </li>
                    
                        <li  data-level="2.2" data-path="Collections/NewCollectionTypes.html">
                            
                            <a href="../Collections/NewCollectionTypes.html">
                                <i class="fa fa-check"></i> <b>2.2.</b> New Collection Types
                            </a>
                            
                        </li>
                    
                        <li  data-level="2.3" data-path="Collections/UtilityClasses.html">
                            
                            <a href="../Collections/UtilityClasses.html">
                                <i class="fa fa-check"></i> <b>2.3.</b> Utility Classes
                            </a>
                            
                        </li>
                    
                        <li  data-level="2.4" data-path="Collections/ExtensionUtilities.html">
                            
                            <a href="../Collections/ExtensionUtilities.html">
                                <i class="fa fa-check"></i> <b>2.4.</b> Extension Utilities
                            </a>
                            
                        </li>
                    
                </ul>
                
            </li>
        
            <li  data-level="3" data-path="Caches/README.html">
                
                <a href="../Caches/README.html">
                    <i class="fa fa-check"></i> <b>3.</b> 缓存[Caches]
                </a>
                
                
            </li>
        
            <li  data-level="4" data-path="FunctionalIdioms/README.html">
                
                <a href="../FunctionalIdioms/README.html">
                    <i class="fa fa-check"></i> <b>4.</b> 函数式风格[Functional idioms]
                </a>
                
                
            </li>
        
            <li  data-level="5" data-path="Concurrency/README.html">
                
                <a href="../Concurrency/README.html">
                    <i class="fa fa-check"></i> <b>5.</b> 并发[Concurrency]
                </a>
                
                
            </li>
        
            <li  data-level="6" data-path="Strings/README.html">
                
                <a href="../Strings/README.html">
                    <i class="fa fa-check"></i> <b>6.</b> 字符串处理[Strings]
                </a>
                
                
            </li>
        
            <li  data-level="7" data-path="Primitives/README.html">
                
                <a href="../Primitives/README.html">
                    <i class="fa fa-check"></i> <b>7.</b> 原生类型[Primitives]
                </a>
                
                
            </li>
        
            <li  data-level="8" data-path="Ranges/README.html">
                
                <a href="../Ranges/README.html">
                    <i class="fa fa-check"></i> <b>8.</b> 区间[Ranges]
                </a>
                
                
            </li>
        
            <li  data-level="9" data-path="IO/README.html">
                
                <a href="../IO/README.html">
                    <i class="fa fa-check"></i> <b>9.</b> I/O
                </a>
                
                
                <ul class="articles">
                    
                        <li  data-level="9.1" data-path="IO/ClosingResources.html">
                            
                            <a href="../IO/ClosingResources.html">
                                <i class="fa fa-check"></i> <b>9.1.</b> 关闭资源ClosingResources
                            </a>
                            
                        </li>
                    
                        <li  data-level="9.2" data-path="IO/Files.html">
                            
                            <a href="../IO/Files.html">
                                <i class="fa fa-check"></i> <b>9.2.</b> Files类常用方法
                            </a>
                            
                        </li>
                    
                </ul>
                
            </li>
        
            <li  data-level="10" data-path="Hash/README.html">
                
                <a href="../Hash/README.html">
                    <i class="fa fa-check"></i> <b>10.</b> 散列[Hash]
                </a>
                
                
                <ul class="articles">
                    
                        <li  data-level="10.1" data-path="Hash/Example.html">
                            
                            <a href="../Hash/Example.html">
                                <i class="fa fa-check"></i> <b>10.1.</b> 样例代码
                            </a>
                            
                        </li>
                    
                </ul>
                
            </li>
        
            <li  data-level="11" data-path="EventBus/README.html">
                
                <a href="../EventBus/README.html">
                    <i class="fa fa-check"></i> <b>11.</b> 事件总线[EventBus]
                </a>
                
                
            </li>
        
            <li  data-level="12" data-path="Math/README.html">
                
                <a href="../Math/README.html">
                    <i class="fa fa-check"></i> <b>12.</b> 数学运算[Math]
                </a>
                
                
            </li>
        
            <li  data-level="13" data-path="Reflection/README.html">
                
                <a href="../Reflection/README.html">
                    <i class="fa fa-check"></i> <b>13.</b> 反射[Reflection]
                </a>
                
                
            </li>
        
    </ul>
</div>

    <div class="book-body">
        <div class="body-inner">
            <div class="page-wrapper" tabindex="-1">
                <div class="book-progress">
    <div class="bar">
        <div class="inner" style="width: 56%;min-width: 52%;"></div>
    </div>
    <div class="chapters">
    
        <a href="../index.html" title="Introduction" class="chapter done new-chapter" data-progress="0" style="left: 0%;"></a>
    
        <a href="../BasicUtilities/README.html" title="基本工具 Basic Utilities" class="chapter done new-chapter" data-progress="1" style="left: 4%;"></a>
    
        <a href="../BasicUtilities/UsingAndAvoidingNull.html" title="Using and avoiding null" class="chapter done " data-progress="1.1" style="left: 8%;"></a>
    
        <a href="../BasicUtilities/Preconditions.html" title="Preconditions" class="chapter done " data-progress="1.2" style="left: 12%;"></a>
    
        <a href="../BasicUtilities/Ordering.html" title="Ordering" class="chapter done " data-progress="1.3" style="left: 16%;"></a>
    
        <a href="../BasicUtilities/ObjectCommonUtilities.html" title="Object common methods" class="chapter done " data-progress="1.4" style="left: 20%;"></a>
    
        <a href="../BasicUtilities/Throwables.html" title="Throwables" class="chapter done " data-progress="1.5" style="left: 24%;"></a>
    
        <a href="../Hash/README.html" title="散列[Hash]" class="chapter done " data-progress="10" style="left: 28%;"></a>
    
        <a href="../Hash/Example.html" title="样例代码" class="chapter done " data-progress="10.1" style="left: 32%;"></a>
    
        <a href="../EventBus/README.html" title="事件总线[EventBus]" class="chapter done " data-progress="11" style="left: 36%;"></a>
    
        <a href="../Math/README.html" title="数学运算[Math]" class="chapter done " data-progress="12" style="left: 40%;"></a>
    
        <a href="../Reflection/README.html" title="反射[Reflection]" class="chapter done " data-progress="13" style="left: 44%;"></a>
    
        <a href="../Collections/README.html" title="集合 Collections" class="chapter done new-chapter" data-progress="2" style="left: 48%;"></a>
    
        <a href="../Collections/ImmutableCollections.html" title="Immutable collections" class="chapter done " data-progress="2.1" style="left: 52%;"></a>
    
        <a href="../Collections/NewCollectionTypes.html" title="New Collection Types" class="chapter done " data-progress="2.2" style="left: 56%;"></a>
    
        <a href="../Collections/UtilityClasses.html" title="Utility Classes" class="chapter  " data-progress="2.3" style="left: 60%;"></a>
    
        <a href="../Collections/ExtensionUtilities.html" title="Extension Utilities" class="chapter  " data-progress="2.4" style="left: 64%;"></a>
    
        <a href="../Caches/README.html" title="缓存[Caches]" class="chapter  new-chapter" data-progress="3" style="left: 68%;"></a>
    
        <a href="../FunctionalIdioms/README.html" title="函数式风格[Functional idioms]" class="chapter  new-chapter" data-progress="4" style="left: 72%;"></a>
    
        <a href="../Concurrency/README.html" title="并发[Concurrency]" class="chapter  new-chapter" data-progress="5" style="left: 76%;"></a>
    
        <a href="../Strings/README.html" title="字符串处理[Strings]" class="chapter  new-chapter" data-progress="6" style="left: 80%;"></a>
    
        <a href="../Primitives/README.html" title="原生类型[Primitives]" class="chapter  new-chapter" data-progress="7" style="left: 84%;"></a>
    
        <a href="../Ranges/README.html" title="区间[Ranges]" class="chapter  new-chapter" data-progress="8" style="left: 88%;"></a>
    
        <a href="../IO/README.html" title="I/O" class="chapter  new-chapter" data-progress="9" style="left: 92%;"></a>
    
        <a href="../IO/ClosingResources.html" title="关闭资源ClosingResources" class="chapter  " data-progress="9.1" style="left: 96%;"></a>
    
        <a href="../IO/Files.html" title="Files类常用方法" class="chapter  " data-progress="9.2" style="left: 100%;"></a>
    
    </div>
</div>

                <div class="page-inner">
                
                    <section class="normal" id="section-gitbook_9">
                    
                        <h1 id="-multisets-multimaps-tables-bidirectional-maps-">新集合类型: multisets, multimaps, tables, bidirectional maps等</h1>
<p>Guava引入了很多JDK没有的、但我们发现明显有用的新集合类型。这些新类型是为了和JDK集合框架共存，而没有往JDK集合抽象中硬塞其他概念。作为一般规则，Guava集合非常精准地遵循了JDK接口契约。</p>
<h1 id="multiset">Multiset</h1>
<p>统计一个词在文档中出现了多少次，传统的做法是这样的：</p>
<pre><code class="lang-java">Map&lt;String, Integer&gt; counts = <span class="hljs-keyword">new</span> HashMap&lt;String, Integer&gt;();
<span class="hljs-keyword">for</span> (String word : words) {
  Integer count = counts.get(word);
  <span class="hljs-keyword">if</span> (count == <span class="hljs-keyword">null</span>) {
    counts.put(word, <span class="hljs-number">1</span>);
  } <span class="hljs-keyword">else</span> {
    counts.put(word, count + <span class="hljs-number">1</span>);
  }
}
</code></pre>
<p>这种写法很笨拙，也容易出错，并且不支持同时收集多种统计信息，如总词数。我们可以做的更好。</p>
<p>Guava提供了一个新集合类型 Multiset，它可以多次添加相等的元素。维基百科从数学角度这样定义Multiset：”集合[set]概念的延伸，它的元素可以重复出现…与集合[set]相同而与元组[tuple]相反的是，Multiset元素的顺序是无关紧要的：Multiset {a, a, b}和{a, b, a}是相等的”。——译者注：这里所说的集合[set]是数学上的概念，Multiset继承自JDK中的Collection接口，而不是Set接口，所以包含重复元素并没有违反原有的接口契约。</p>
<p>可以用两种方式看待Multiset：</p>
<ul>
<li>没有元素顺序限制的ArrayList<E></li>
<li>Map<E, Integer>，键为元素，值为计数</li>
</ul>
<p>Guava的Multiset API也结合考虑了这两种方式：</p>
<p>当把Multiset看成普通的Collection时，它表现得就像无序的ArrayList：</p>
<ul>
<li>add(E)添加单个给定元素</li>
<li>iterator()返回一个迭代器，包含Multiset的所有元素（包括重复的元素）</li>
<li>size()返回所有元素的总个数（包括重复的元素）</li>
</ul>
<p>当把Multiset看作Map<E, Integer>时，它也提供了符合性能期望的查询操作：</p>
<ul>
<li>count(Object)返回给定元素的计数。HashMultiset.count的复杂度为O(1)，TreeMultiset.count的复杂度为O(log n)。</li>
<li>entrySet()返回Set<Multiset.Entry<E>&gt;，和Map的entrySet类似。</li>
<li>elementSet()返回所有不重复元素的Set<E>，和Map的keySet()类似。</li>
<li>所有Multiset实现的内存消耗随着不重复元素的个数线性增长。</li>
</ul>
<p>值得注意的是，除了极少数情况，Multiset和JDK中原有的Collection接口契约完全一致——具体来说，TreeMultiset在判断元素是否相等时，与TreeSet一样用compare，而不是Object.equals。另外特别注意，Multiset.addAll(Collection)可以添加Collection中的所有元素并进行计数，这比用for循环往Map添加元素和计数方便多了。</p>
<table>
<thead>
<tr>
<th>方法</th>
<th>描述 </th>
</tr>
</thead>
<tbody>
<tr>
<td>count(E)</td>
<td>给定元素在Multiset中的计数</td>
</tr>
<tr>
<td>elementSet()</td>
<td>Multiset中不重复元素的集合，类型为Set<E></td>
</tr>
<tr>
<td>entrySet()</td>
<td>和Map的entrySet类似，返回Set<Multiset.Entry<E>&gt;，其中包含的Entry支持getElement()和getCount()方法</td>
</tr>
<tr>
<td>add(E, int)</td>
<td>增加给定元素在Multiset中的计数</td>
</tr>
<tr>
<td>remove(E, int)</td>
<td>减少给定元素在Multiset中的计数</td>
</tr>
<tr>
<td>setCount(E, int)</td>
<td>设置给定元素在Multiset中的计数，不可以为负数</td>
</tr>
<tr>
<td>size()</td>
<td>返回集合元素的总个数（包括重复的元素）</td>
</tr>
</tbody>
</table>
<h2 id="multiset-map">Multiset不是Map</h2>
<p>请注意，Multiset<E>不是Map<E, Integer>，虽然Map可能是某些Multiset实现的一部分。准确来说Multiset是一种Collection类型，并履行了Collection接口相关的契约。关于Multiset和Map的显著区别还包括：</p>
<ul>
<li>Multiset中的元素计数只能是正数。任何元素的计数都不能为负，也不能是0。elementSet()和entrySet()视图中也不会有这样的元素。</li>
<li>multiset.size()返回集合的大小，等同于所有元素计数的总和。对于不重复元素的个数，应使用elementSet().size()方法。（因此，add(E)把multiset.size()增加1）</li>
<li>multiset.iterator()会迭代重复元素，因此迭代长度等于multiset.size()。</li>
<li>Multiset支持直接增加、减少或设置元素的计数。setCount(elem, 0)等同于移除所有elem。</li>
<li>对multiset 中没有的元素，multiset.count(elem)始终返回0。</li>
</ul>
<h2 id="multiset-">Multiset的各种实现</h2>
<p>Guava提供了多种Multiset的实现，大致对应JDK中Map的各种实现：</p>
<table>
<thead>
<tr>
<th>Map</th>
<th>对应的Multiset</th>
<th>是否支持null元素</th>
</tr>
</thead>
<tbody>
<tr>
<td>HashMap</td>
<td>HashMultiset</td>
<td>是</td>
</tr>
<tr>
<td>TreeMap</td>
<td>TreeMultiset</td>
<td>是（如果comparator支持的话）</td>
</tr>
<tr>
<td>LinkedHashMap</td>
<td>LinkedHashMultiset</td>
<td>是</td>
</tr>
<tr>
<td>ConcurrentHashMap</td>
<td>ConcurrentHashMultiset</td>
<td>否</td>
</tr>
<tr>
<td>ImmutableMap</td>
<td>ImmutableMultiset</td>
<td>否</td>
</tr>
</tbody>
</table>
<h1 id="sortedmultiset">SortedMultiset</h1>
<p>SortedMultiset是Multiset 接口的变种，它支持高效地获取指定范围的子集。比方说，你可以用 latencies.subMultiset(0,BoundType.CLOSED, 100, BoundType.OPEN).size()来统计你的站点中延迟在100毫秒以内的访问，然后把这个值和latencies.size()相比，以获取这个延迟水平在总体访问中的比例。</p>
<p>TreeMultiset实现SortedMultiset接口。在撰写本文档时，ImmutableSortedMultiset还在测试和GWT的兼容性。</p>
<h1 id="multimap">Multimap</h1>
<p>每个有经验的Java程序员都在某处实现过Map<K, List<V>&gt;或Map<K, Set<V>&gt;，并且要忍受这个结构的笨拙。例如，Map<K, Set<V>&gt;通常用来表示非标定有向图。Guava的 Multimap可以很容易地把一个键映射到多个值。换句话说，Multimap是把键映射到任意多个值的一般方式。</p>
<p>可以用两种方式思考Multimap的概念：”键-单个值映射”的集合：</p>
<p>a -&gt; 1 a -&gt; 2 a -&gt;4 b -&gt; 3 c -&gt; 5</p>
<p>或者”键-值集合映射”的映射：</p>
<p>a -&gt; [1, 2, 4] b -&gt; 3 c -&gt; 5</p>
<p>一般来说，Multimap接口应该用第一种方式看待，但asMap()视图返回Map<K, Collection<V>&gt;，让你可以按另一种方式看待Multimap。重要的是，不会有任何键映射到空集合：一个键要么至少到一个值，要么根本就不在Multimap中。</p>
<p>很少会直接使用Multimap接口，更多时候你会用ListMultimap或SetMultimap接口，它们分别把键映射到List或Set。</p>
<h2 id="-multimap">修改Multimap</h2>
<p>Multimap.get(key)以集合形式返回键所对应的值视图，即使没有任何对应的值，也会返回空集合。ListMultimap.get(key)返回List，SetMultimap.get(key)返回Set。</p>
<p>对值视图集合进行的修改最终都会反映到底层的Multimap。例如：</p>
<pre><code class="lang-java">Set&lt;Person&gt; aliceChildren = childrenMultimap.get(alice);
aliceChildren.clear();
aliceChildren.add(bob);
aliceChildren.add(carol);
</code></pre>
<p>其他（更直接地）修改Multimap的方法有：</p>
<p>方法签名    描述    等价于
---                             | ---                        | ---
put(K, V)                        | 添加键到单个值的映射            | multimap.get(key).add(value)
putAll(K, Iterable<V>)            | 依次添加键到多个值的映射        | Iterables.addAll(multimap.get(key), values)
remove(K, V)                    | 移除键到值的映射；如果有这样的键值并成功移除，返回true。    | multimap.get(key).remove(value)
removeAll(K)                    | 清除键对应的所有值，返回的集合包含所有之前映射到K的值，但修改这个集合就不会影响Multimap了。        | multimap.get(key).clear()
replaceValues(K, Iterable<V>)    | 清除键对应的所有值，并重新把key关联到Iterable中的每个元素。返回的集合包含所有之前映射到K的值。    | multimap.get(key).clear(); Iterables.addAll(multimap.get(key), values)</p>
<h2 id="multimap-">Multimap的视图</h2>
<p>Multimap还支持若干强大的视图：</p>
<ul>
<li>asMap为Multimap<K, V>提供Map<K,Collection<V>&gt;形式的视图。返回的Map支持remove操作，并且会反映到底层的Multimap，但它不支持put或putAll操作。更重要的是，如果你想为Multimap中没有的键返回null，而不是一个新的、可写的空集合，你就可以使用asMap().get(key)。（你可以并且应当把asMap.get(key)返回的结果转化为适当的集合类型——如SetMultimap.asMap.get(key)的结果转为Set，ListMultimap.asMap.get(key)的结果转为List——Java类型系统不允许ListMultimap直接为asMap.get(key)返回List——译者注：也可以用Multimaps中的asMap静态方法帮你完成类型转换）</li>
<li>entries用Collection<Map.Entry<K, V>&gt;返回Multimap中所有”键-单个值映射”——包括重复键。（对SetMultimap，返回的是Set）</li>
<li>keySet用Set表示Multimap中所有不同的键。</li>
<li>keys用Multiset表示Multimap中的所有键，每个键重复出现的次数等于它映射的值的个数。可以从这个Multiset中移除元素，但不能做添加操作；移除操作会反映到底层的Multimap。</li>
<li>values()用一个”扁平”的Collection<V>包含Multimap中的所有值。这有一点类似于Iterables.concat(multimap.asMap().values())，但它直接返回了单个Collection，而不像multimap.asMap().values()那样是按键区分开的Collection。</li>
</ul>
<h2 id="multimap-map">Multimap不是Map</h2>
<p>Multimap<K, V>不是Map<K,Collection<V>&gt;，虽然某些Multimap实现中可能使用了map。它们之间的显著区别包括：</p>
<ul>
<li>Multimap.get(key)总是返回非null、但是可能空的集合。这并不意味着Multimap为相应的键花费内存创建了集合，而只是提供一个集合视图方便你为键增加映射值——译者注：如果有这样的键，返回的集合只是包装了Multimap中已有的集合；如果没有这样的键，返回的空集合也只是持有Multimap引用的栈对象，让你可以用来操作底层的Multimap。因此，返回的集合不会占据太多内存，数据实际上还是存放在Multimap中。</li>
<li>如果你更喜欢像Map那样，为Multimap中没有的键返回null，请使用asMap()视图获取一个Map<K, Collection<V>&gt;。（或者用静态方法Multimaps.asMap()为ListMultimap返回一个Map<K, List<V>&gt;。对于SetMultimap和SortedSetMultimap，也有类似的静态方法存在）</li>
<li>当且仅当有值映射到键时，Multimap.containsKey(key)才会返回true。尤其需要注意的是，如果键k之前映射过一个或多个值，但它们都被移除后，Multimap.containsKey(key)会返回false。</li>
<li>Multimap.entries()返回Multimap中所有”键-单个值映射”——包括重复键。如果你想要得到所有”键-值集合映射”，请使用asMap().entrySet()。</li>
<li>Multimap.size()返回所有”键-单个值映射”的个数，而非不同键的个数。要得到不同键的个数，请改用Multimap.keySet().size()。</li>
</ul>
<h2 id="multimap-">Multimap的各种实现</h2>
<p>Multimap提供了多种形式的实现。在大多数要使用Map<K, Collection<V>&gt;的地方，你都可以使用它们：</p>
<table>
<thead>
<tr>
<th>实现</th>
<th>键行为类似</th>
<th>值行为类似</th>
</tr>
</thead>
<tbody>
<tr>
<td>ArrayListMultimap</td>
<td>HashMap</td>
<td>ArrayList</td>
</tr>
<tr>
<td>HashMultimap</td>
<td>HashMap</td>
<td>HashSet</td>
</tr>
<tr>
<td>LinkedListMultimap*</td>
<td>LinkedHashMap*</td>
<td>LinkedList*</td>
</tr>
<tr>
<td>LinkedHashMultimap**</td>
<td>LinkedHashMap</td>
<td>LinkedHashMap</td>
</tr>
<tr>
<td>TreeMultimap</td>
<td>TreeMap</td>
<td>TreeSet</td>
</tr>
<tr>
<td>ImmutableListMultimap</td>
<td>ImmutableMap</td>
<td>ImmutableList</td>
</tr>
<tr>
<td>ImmutableSetMultimap</td>
<td>ImmutableMap</td>
<td>ImmutableSet</td>
</tr>
</tbody>
</table>
<p>除了两个不可变形式的实现，其他所有实现都支持null键和null值</p>
<p>*LinkedListMultimap.entries()保留了所有键和值的迭代顺序。详情见doc链接。</p>
<p>**LinkedHashMultimap保留了映射项的插入顺序，包括键插入的顺序，以及键映射的所有值的插入顺序。</p>
<p>请注意，并非所有的Multimap都和上面列出的一样，使用Map<K, Collection<V>&gt;来实现（特别是，一些Multimap实现用了自定义的hashTable，以最小化开销）</p>
<p>如果你想要更大的定制化，请用Multimaps.newMultimap(Map, Supplier<Collection>)或list和 set版本，使用自定义的Collection、List或Set实现Multimap。</p>
<h1 id="bimap">BiMap</h1>
<p>传统上，实现键值对的双向映射需要维护两个单独的map，并保持它们间的同步。但这种方式很容易出错，而且对于值已经在map中的情况，会变得非常混乱。例如：</p>
<pre><code class="lang-java">Map&lt;String, Integer&gt; nameToId = Maps.newHashMap();
Map&lt;Integer, String&gt; idToName = Maps.newHashMap();

nameToId.put(<span class="hljs-string">"Bob"</span>, <span class="hljs-number">42</span>);
idToName.put(<span class="hljs-number">42</span>, <span class="hljs-string">"Bob"</span>);
<span class="hljs-comment">// what happens if "Bob" or 42 are already present?</span>
<span class="hljs-comment">// weird bugs can arise if we forget to keep these in sync...</span>
<span class="hljs-comment">//如果"Bob"和42已经在map中了，会发生什么?</span>
<span class="hljs-comment">//如果我们忘了同步两个map，会有诡异的bug发生...</span>
</code></pre>
<p>BiMap<K, V>是特殊的Map：</p>
<ul>
<li>可以用 inverse()反转BiMap<K, V>的键值映射</li>
<li>保证值是唯一的，因此 values()返回Set而不是普通的Collection</li>
</ul>
<p>在BiMap中，如果你想把键映射到已经存在的值，会抛出IllegalArgumentException异常。如果对特定值，你想要强制替换它的键，请使用 BiMap.forcePut(key, value)。</p>
<pre><code class="lang-java">BiMap&lt;String, Integer&gt; userId = HashBiMap.create();
...
String userForId = userId.inverse().get(id);
</code></pre>
<h2 id="bimap-">BiMap的各种实现</h2>
<table>
<thead>
<tr>
<th>键-值实现</th>
<th>值-键实现</th>
<th>对应的BiMap实现</th>
</tr>
</thead>
<tbody>
<tr>
<td>HashMap</td>
<td>HashMap</td>
<td>HashBiMap</td>
</tr>
<tr>
<td>ImmutableMap</td>
<td>ImmutableMap</td>
<td>ImmutableBiMap</td>
</tr>
<tr>
<td>EnumMap</td>
<td>EnumMap</td>
<td>EnumBiMap</td>
</tr>
<tr>
<td>EnumMap</td>
<td>HashMap</td>
<td>EnumHashBiMap</td>
</tr>
</tbody>
</table>
<p>注：Maps类中还有一些诸如synchronizedBiMap的BiMap工具方法.</p>
<h1 id="table">Table</h1>
<pre><code class="lang-java">Table&lt;Vertex, Vertex, Double&gt; weightedGraph = HashBasedTable.create();
weightedGraph.put(v1, v2, <span class="hljs-number">4</span>);
weightedGraph.put(v1, v3, <span class="hljs-number">20</span>);
weightedGraph.put(v2, v3, <span class="hljs-number">5</span>);

weightedGraph.row(v1); <span class="hljs-comment">// returns a Map mapping v2 to 4, v3 to 20</span>
weightedGraph.column(v3); <span class="hljs-comment">// returns a Map mapping v1 to 20, v2 to 5</span>
</code></pre>
<p>通常来说，当你想使用多个键做索引的时候，你可能会用类似Map<FirstName, Map<LastName, Person>&gt;的实现，这种方式很丑陋，使用上也不友好。Guava为此提供了新集合类型Table，它有两个支持所有类型的键：”行”和”列”。Table提供多种视图，以便你从各种角度使用它：</p>
<ul>
<li>rowMap()：用Map<R, Map<C, V>&gt;表现Table<R, C, V>。同样的， rowKeySet()返回”行”的集合Set<R>。</li>
<li>row(r) ：用Map<C, V>返回给定”行”的所有列，对这个map进行的写操作也将写入Table中。</li>
<li>类似的列访问方法：columnMap()、columnKeySet()、column(c)。（基于列的访问会比基于的行访问稍微低效点）</li>
<li>cellSet()：用元素类型为Table.Cell<R, C, V>的Set表现Table<R, C, V>。Cell类似于Map.Entry，但它是用行和列两个键区分的。</li>
</ul>
<p>Table有如下几种实现：</p>
<ul>
<li>HashBasedTable：本质上用HashMap<R, HashMap<C, V>&gt;实现；</li>
<li>TreeBasedTable：本质上用TreeMap<R, TreeMap<C,V>&gt;实现；</li>
<li>ImmutableTable：本质上用ImmutableMap<R, ImmutableMap<C, V>&gt;实现；注：ImmutableTable对稀疏或密集的数据集都有优化。</li>
<li>ArrayTable：要求在构造时就指定行和列的大小，本质上由一个二维数组实现，以提升访问速度和密集Table的内存利用率。ArrayTable与其他Table的工作原理有点不同，请参见Javadoc了解详情。</li>
</ul>
<h1 id="classtoinstancemap">ClassToInstanceMap</h1>
<p>ClassToInstanceMap是一种特殊的Map：它的键是类型，而值是符合键所指类型的对象。</p>
<p>为了扩展Map接口，ClassToInstanceMap额外声明了两个方法：T getInstance(Class<T>) 和T putInstance(Class<T>, T)，从而避免强制类型转换，同时保证了类型安全。</p>
<p>ClassToInstanceMap有唯一的泛型参数，通常称为B，代表Map支持的所有类型的上界。例如：</p>
<pre><code class="lang-java">ClassToInstanceMap&lt;Number&gt; numberDefaults = MutableClassToInstanceMap.create();
numberDefaults.putInstance(Integer.class, Integer.valueOf(<span class="hljs-number">0</span>));
</code></pre>
<p>从技术上讲，ClassToInstanceMap<B>实现了Map<Class<? extends B>, B&gt;——或者换句话说，是一个映射B的子类型到对应实例的Map。这让ClassToInstanceMap包含的泛型声明有点令人困惑，但请记住B始终是Map所支持类型的上界——通常B就是Object。</p>
<p>对于ClassToInstanceMap，Guava提供了两种有用的实现：MutableClassToInstanceMap和 ImmutableClassToInstanceMap。</p>
<h1 id="rangeset">RangeSet</h1>
<p>RangeSet描述了一组不相连的、非空的区间。当把一个区间添加到可变的RangeSet时，所有相连的区间会被合并，空区间会被忽略。例如：</p>
<pre><code>RangeSet&lt;Integer&gt; rangeSet = TreeRangeSet.create();
rangeSet.add(Range.closed(1, 10)); // {[1, 10]}
rangeSet.add(Range.closedOpen(11, 15)); // disconnected range: {[1, 10], [11, 15)} 
rangeSet.add(Range.closedOpen(15, 20)); // connected range; {[1, 10], [11, 20)}
rangeSet.add(Range.openClosed(0, 0)); // empty range; {[1, 10], [11, 20)}
rangeSet.remove(Range.open(5, 10)); // splits [1, 10]; {[1, 5], [10, 10], [11, 20)}
</code></pre><p>请注意，要合并Range.closed(1, 10)和Range.closedOpen(11, 15)这样的区间，你需要首先用Range.canonical(DiscreteDomain)对区间进行预处理，例如DiscreteDomain.integers()。</p>
<p>注：RangeSet不支持GWT，也不支持JDK5和更早版本；因为，RangeSet需要充分利用JDK6中NavigableMap的特性。</p>
<h2 id="rangeset-">RangeSet的视图</h2>
<p>RangeSet的实现支持非常广泛的视图：</p>
<ul>
<li>complement()：返回RangeSet的补集视图。complement也是RangeSet类型,包含了不相连的、非空的区间。</li>
<li>subRangeSet(Range<C>)：返回RangeSet与给定Range的交集视图。这扩展了传统排序集合中的headSet、subSet和tailSet操作。</li>
<li>asRanges()：用Set<Range<C>&gt;表现RangeSet，这样可以遍历其中的Range。</li>
<li>asSet(DiscreteDomain<C>)（仅ImmutableRangeSet支持）：用ImmutableSortedSet<C>表现RangeSet，以区间中所有元素的形式而不是区间本身的形式查看。（这个操作不支持DiscreteDomain 和RangeSet都没有上边界，或都没有下边界的情况）</li>
</ul>
<h2 id="rangeset-">RangeSet的查询方法</h2>
<p>为了方便操作，RangeSet直接提供了若干查询方法，其中最突出的有:</p>
<ul>
<li>contains(C)：RangeSet最基本的操作，判断RangeSet中是否有任何区间包含给定元素。</li>
<li>rangeContaining(C)：返回包含给定元素的区间；若没有这样的区间，则返回null。</li>
<li>encloses(Range<C>)：简单明了，判断RangeSet中是否有任何区间包括给定区间。
span()：返回包括RangeSet中所有区间的最小区间。</li>
</ul>
<h1 id="rangemap">RangeMap</h1>
<p>RangeMap描述了&quot;不相交的、非空的区间&quot;到特定值的映射。和RangeSet不同，RangeMap不会合并相邻的映射，即便相邻的区间映射到相同的值。例如：</p>
<pre><code class="lang-java">RangeMap&lt;Integer, String&gt; rangeMap = TreeRangeMap.create();
rangeMap.put(Range.closed(<span class="hljs-number">1</span>, <span class="hljs-number">10</span>), <span class="hljs-string">"foo"</span>); <span class="hljs-comment">// {[1, 10] =&gt; "foo"}</span>
rangeMap.put(Range.open(<span class="hljs-number">3</span>, <span class="hljs-number">6</span>), <span class="hljs-string">"bar"</span>); <span class="hljs-comment">// {[1, 3] =&gt; "foo", (3, 6) =&gt; "bar", [6, 10] =&gt; "foo"}</span>
rangeMap.put(Range.open(<span class="hljs-number">10</span>, <span class="hljs-number">20</span>), <span class="hljs-string">"foo"</span>); <span class="hljs-comment">// {[1, 3] =&gt; "foo", (3, 6) =&gt; "bar", [6, 10] =&gt; "foo", (10, 20) =&gt; "foo"}</span>
rangeMap.remove(Range.closed(<span class="hljs-number">5</span>, <span class="hljs-number">11</span>)); <span class="hljs-comment">// {[1, 3] =&gt; "foo", (3, 5) =&gt; "bar", (11, 20) =&gt; "foo"}</span>
</code></pre>
<h2 id="rangemap-">RangeMap的视图</h2>
<p>RangeMap提供两个视图：</p>
<ul>
<li>asMapOfRanges()：用Map<Range<K>, V&gt;表现RangeMap。这可以用来遍历RangeMap。</li>
<li>subRangeMap(Range<K>)：用RangeMap类型返回RangeMap与给定Range的交集视图。这扩展了传统的headMap、subMap和tailMap操作。</li>
</ul>

                    
                    </section>
                
                </div>
            </div>
        </div>

        
        <a href="../Collections/ImmutableCollections.html" class="navigation navigation-prev"><i class="fa fa-angle-left"></i></a>
        
        
        <a href="../Collections/UtilityClasses.html" class="navigation navigation-next"><i class="fa fa-angle-right"></i></a>
        
    </div>
</div>

        

        <script src="https://cdnjs.cloudflare.com/ajax/libs/ace/1.1.3/ace.js"></script>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/ace/1.1.3/mode-javascript.js"></script>
        <script src="../gitbook/jsrepl/jsrepl.js" id="jsrepl-script"></script>
        <script src="../gitbook/app.js"></script>
        

    
    <script src="../gitbook/plugins/gitbook-plugin-mixpanel/plugin.js"></script>
    

    
    <script src="http://cdn.mathjax.org/mathjax/2.0-latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    

    
    <script src="../gitbook/plugins/gitbook-plugin-mathjax/plugin.js"></script>
    

<script>
require(["gitbook"], function(gitbook) {
    var config = {};
    gitbook.start(config);
});
</script>

    </body>
</html>
